/**
 * _id: 644b737901cd726a5f7c36aa
 * this _id is not generated by mongoDB, it is generated by the mongoDB driver.
 * and if using mongoose, it is generated by mongoose. because mongoose is an abstraction over mongoDB driver.
 * means this _id generated before the document is inserted into the database. (art.save())
 * in MySQL or PostgreSQL, the id is generated after the document is inserted into the database.
 * that's why applications built on mongoDB can scale better than applications built on MySQL or PostgreSQL.
 * beacause we are not talking to a central authority to geenrate the id. or get the id.
 *
 * 12 bytes
 *  4 bytes: timestamp
 *  3 bytes: machine identifier (two diff machines, two diff identifiers)
 *  2 bytes: process identifier (two diff processes, two diff identifiers)
 *  3 bytes: counter (random value incremented when generating an objectId in the same process)
 * if you one same machine, same process, same time, differnet counter, you will get different objectId
 *
 * 24 characters
 * 12 bytes
 * 2 hex characters per byte
 *
 * 1 byte = 8 bits
 * 2 ^ 8 = 256
 * 2 ^ 24 = 16M (24 bits of 3 bytes of counter)
 * means, in the same machine, same process, same time, you can generate 16M different objectId
 *
 *
 */

const mongoose = require("../export").mongoose;
const id = new mongoose.Types.ObjectId();
console.log("_id: ", id);
console.log("timestamp: ", id.getTimestamp());
console.log("machine identifier: ", id.id.slice(0, 4));
console.log("process identifier: ", id.id.slice(4, 6));
console.log("counter: ", id.id.slice(6, 9));
console.log(id._bsontype);
console.log(mongoose.Types.ObjectId.isValid(id));
console.log(mongoose.Types.ObjectId.toString(id));

const Joi = require('../export').hapiJoi
Joi.objectId = (require('../export').joiObjectId)(Joi)

const schema = Joi.object({
  _id: Joi.objectId(),
  name: Joi.string().max(100),
})

const data1 = {
  _id: '123',
  name: 'test',
};
console.log(schema.validate(data1).error);